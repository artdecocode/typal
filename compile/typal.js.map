{
"version":3,
"file":"compile/typal.js",
"lineCount":703,
"mappings":"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",
"sources":[" [synthetic:util/defineproperty] "," [synthetic:util/global] "," [synthetic:util/polyfill] "," [synthetic:es6/string/trimend] ","node_modules/mismatch/src/index.js","node_modules/rexml/src/lib/res-simple.js","node_modules/rexml/src/index.js","node_modules/rexml/src/lib/index.js","node_modules/@typedefs/parser/src/lib.js","node_modules/@typedefs/parser/src/tokens.js","node_modules/@typedefs/parser/src/index.js","src/lib/index.js","src/lib/Arg.js","src/lib/Property.js","src/lib/get-links.js","src/lib/make-props-table.js","src/lib/Type.js","src/lib/Method.js","src/lib/Import.js","node_modules/os/index.js","node_modules/@artdeco/clean-stack/src/index.js","src/lib/parse.js","src/depack.js"],
"sourcesContent":["/*\n * Copyright 2016 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Provides methods to polyfill native objects.\n * @suppress {reportUnknownTypes}\n */\n'require util/defines';\n\n\n/**\n * Polyfill for Object.defineProperty() method:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\n *\n * Refuses to define properties on Array.prototype and Object.prototype,\n * since we can't make them non-enumerable and this messes up peoples' for\n * loops.  Beyond this, we simply assign values and not worry\n * about enumerability or writeability.\n * @param {?} target\n * @param {string} property\n * @param {?} descriptor\n * @suppress {reportUnknownTypes}\n */\n$jscomp.defineProperty =\n    $jscomp.ASSUME_ES5 || typeof Object.defineProperties == 'function' ?\n    Object.defineProperty :\n    function(target, property, descriptor) {\n      descriptor = /** @type {!ObjectPropertyDescriptor} */ (descriptor);\n      // NOTE: This is currently never called with a descriptor outside\n      // the control of the compiler.  If we ever decide to polyfill either\n      // Object.defineProperty or Reflect.defineProperty for ES3, we should\n      // explicitly check for `get` or `set` on the descriptor and throw a\n      // TypeError, since it's impossible to properly polyfill it.\n      if (target == Array.prototype || target == Object.prototype) return;\n      target[property] = descriptor.value;\n    };\n","/*\n * Copyright 2016 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Runtime code to store the global object.\n */\n'require base';\n\n\n/**\n * @param {!Object} maybeGlobal\n * @return {!Object} The global object.\n * @suppress {undefinedVars|reportUnknownTypes}\n */\n$jscomp.getGlobal = function(maybeGlobal) {\n  // This logic can be simplified to be made more optimizable.\n  return (typeof window != 'undefined' && window === maybeGlobal) ?\n      maybeGlobal :\n      (typeof global != 'undefined' && global != null) ?\n      /** @type {!Object} */ (global) :\n      maybeGlobal;\n};\n\n\n// TODO(sdh): This should be typed as \"the global object\" now that the type\n// of \"Global\" has landed in the type system.\n/**\n * The global object. For browsers we could just use `this` but in Node that\n * doesn't work.\n * @const {?}\n */\n$jscomp.global = $jscomp.getGlobal(this);\n","/*\n * Copyright 2016 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Provides methods to polyfill native objects.\n */\n'require util/defineproperty';\n'require util/global';\n\n\n/**\n * @param {string} target Qualified name of the class or method to polyfill,\n *     e.g. 'Array.prototype.includes' or 'Map'.\n * @param {?function(*): *} polyfill A function that takes the current browser\n *     implementation of the target and returns an optional new polyfill\n *     implementation.  If null is returned, then no polyfill will be added.  A\n *     null argument for this parameter indicates that the function will not be\n *     polyfilled, and is only useful for `build_polyfill_table.js` bookkeeping.\n * @param {string} fromLang The language level in which the target is expected\n *     to already be present in the browser.  The compiler requires that\n *     `languageOut < fromLang` before injecting a polyfill (i.e. if the\n *     specified output language already includes the feature then there's no\n *     need to polyfill it).\n * @param {string} toLang The language level required by the polyfill\n *     implementation.  The compiler will issue an error if a polyfill is\n *     required, but `languageOut < toLang`.  Additionally, the\n *     `build_polyfill_table.js` script audits the polyfill dependency tree to\n *     ensure that no polyfill with a lower `toLang` depends on one with a\n *     higher `toLang`.\n * @suppress {reportUnknownTypes}\n * @noinline\n * NOTE: We prevent inlining so RemoveUnusedPolyfills can always recognize this\n * call.\n */\n$jscomp.polyfill = function(target, polyfill, fromLang, toLang) {\n  if (!polyfill) return;\n  var obj = $jscomp.global;\n  var split = target.split('.');\n  for (var i = 0; i < split.length - 1; i++) {\n    var key = split[i];\n    if (!(key in obj)) obj[key] = {};  // Might want to be defineProperty.\n    obj = obj[key];\n  }\n  var property = split[split.length - 1];\n  var orig = obj[property];\n  var impl = polyfill(orig);\n  if (impl == orig || impl == null) return;\n  $jscomp.defineProperty(\n      obj, property, {configurable: true, writable: true, value: impl});\n};\n","/*\n * Copyright 2019 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview\n * @suppress {uselessCode}\n */\n'require util/polyfill';\n\n// Most browsers implemented trimRight around ES5-time-frame, but it wasn't\n// officially part of the language specification until ES_2019, so we have\n// to provide a polyfill for it.\n// IE11 doesn't have it, of course...\n$jscomp.polyfill('String.prototype.trimRight', function(orig) {\n  /**\n   * @this {string}\n   * @return {string}\n   */\n  function polyfill() {\n    return this.replace(/[\\s\\xa0]+$/, '');\n  }\n  return orig || polyfill;\n}, 'es_2019', 'es3');\n\n$jscomp.polyfill('String.prototype.trimEnd', function(orig) {\n  return orig || String.prototype.trimRight;\n}, 'es_2019', 'es3');\n","/**\n * Returns an array of captured groups of a regular expression as objects. Does not modify the `lastIndex` property of the regex.\n * @param {RegExp} re The regular expression used for matching.\n * @param {string} string String to find matches in.\n * @param {Array<string>} keys Keys to use to create an captured group object.\n * @param {boolean} addPositions Whether to include positions in the return.\n * @example\n *\n```js\nconst re = /(test) inside of a (string)(\\d)?/ig\nconst s = 'Test inside of a STRING1. TEST inside of a string.'\nconst keys = ['test', 'string', 'number']\nconst res = mismatch(re, s, keys)\n\n// result:\n[\n {\n   test: 'Test',\n   string: 'STRING',\n   number: '1',\n },\n {\n   test: 'TEST',\n   string: 'string',\n },\n]\n```\n */\nexport default function mismatch(re, string, keys, addPositions = false) {\n  /** @type {!Array<!Object<string, string>>} */\n  const m = []\n  string.replace(re, (match, ...args) => {\n    // remove position and input\n    const position = args[args.length - 2]\n    const start = addPositions ? { position } : {}\n    const p = args.slice(0, args.length - 2)\n    const o = p.reduce((acc, capturedGroup, i) => {\n      const key = keys[i]\n      if (!(key && capturedGroup !== undefined)) return acc\n      acc[key] = capturedGroup\n      return acc\n    }, start)\n    m.push(o)\n  })\n  return m\n}","const nameRe = /([^\\s>=/]+)/\nconst valRe = /(?:\"([\\s\\S]*?)\"|'([\\s\\S]*?)')/\n\nexport const attributeRe = new RegExp(`${nameRe.source}(?:\\\\s*=\\\\s*${valRe.source})?`, 'g')\n\n/**\n * This regex will match all attributes as a string inside of element, e.g., matching `<el attr=\"abc\" bool/>` will result in `attr=\"abc\" bool`.\n */\nexport const attributesRe = new RegExp(`(?:\\\\s+((?:${attributeRe.source}\\\\s*)*))`)\n","import mismatch from 'mismatch'\nimport { extractProps as extractPropsSpec, getPropValue } from './lib'\nimport { attributesRe } from './lib/res'\nimport { attributesRe as simple, attributeRe as simpleAttribute } from './lib/res-simple'\n\nconst execRes = (re, s) => {\n  const res = re.exec(s)\n  if (!res) return res\n  const [, ...args] = res\n  return args\n}\n\n/**\n * Extract member elements from an XML string. Numbers and booleans will be parsed into their JS types.\n * @param {string|!Array<string>} tag Which tag to extract, e.g., `div`. Can also pass an array of tags, in which case the name of the tag will also be returned.\n * @param {string} string The XML string.\n * @example\n *\n * const xml = `\n * <html>\n *   <div id=\"1\" class=\"test\" contenteditable>\n *     Hello World\n *   </div>\n * </html>\n * `\n * const [{ content, props }] = extractTag('div', xml)\n * // content: Hello World\n * // props: { id: 1, class: 'test', contenteditable: true }\n */\nconst extractTags = (tag, string) => {\n  const tags = Array.isArray(tag) ? tag : [tag]\n  const t = tags.join('|')\n  const end1 = /\\s*\\/>/\n  const end2 = />([\\s\\S]+?)?<\\/\\1>/\n  const re = new RegExp(`<(${t})${simple.source}?(?:${end1.source}|${end2.source})`, 'g')\n\n  const matches = mismatch(re, string, ['t', 'a', 'v', 'v1', 'v2', 'c'])\n  const res = matches.map(({ 't': tagName, 'a': attributes = '', 'c': content = '' }) => {\n    const attrs = attributes.replace(/\\/$/, '').trim()\n    const props = extractProps(attrs)\n    return { content, props, tag: tagName }\n  })\n  return res\n}\n\n/**\n * Extracts the properties from the attributes part of the tag and returns them as an object. It will parse values if not specified otherwise.\n * @param {string} string The attribute part of the tag.\n * @param {boolean} parseValue Whether to transform the value into its value.\n */\nexport const extractProps = (string, parseValue = true) => {\n  const m = mismatch(simpleAttribute, string, ['key', 'val', 'def', 'f'])\n  const props = m\n    .reduce((acc, { 'key': key, 'val': val }) => {\n      if (val === undefined) {\n        acc[key] = true\n        return acc\n      }\n      acc[key] = parseValue ? getPropValue(val) : val\n      return acc\n    }, {})\n  return props\n}\n\n/**\n * Extract member elements from an XML string using the complex regular expression to match attributes that confirms to the XML spec. Numbers and booleans will be parsed into their JS types.\n * @param {string} tag Which tag to extract, e.g., `div`.\n * @param {string} string The XML string.\n * @example\n *\n * const xml = `\n<html>\n  <div id=\"1\" class=\"test\" contenteditable>\n    Hello World\n  </div>\n</html>\n`\n * const [{ content, props }] = extractTag('div', xml)\n * // content: Hello World\n * // props: { id: 1, class: 'test', contenteditable: true }\n */\nexport const extractTagsSpec = (tag, string) => {\n  const end1 = /\\s*\\/>/\n  const end2 = new RegExp(`>([\\\\s\\\\S]+?)?</${tag}>`)\n  const re = new RegExp(`<${tag}${attributesRe.source}?(?:${end1.source}|${end2.source})`, 'gu')\n  const r = []\n\n  let t\n  while ((t = execRes(re, string))) {\n    if (!t.length) continue\n    const [_p = '', _c = ''] = t\n    const p = _p.replace(/\\/$/, '').trim()\n    const props = extractProps(p)\n    const item = {\n      props,\n      content: _c,\n    }\n    r.push(item)\n  }\n  return r\n}\n\nexport default extractTags\nexport { extractPropsSpec }","import { attributeRe } from './res'\n\nexport const getPropValue = (val) => {\n  if (val == 'true') return true\n  if (val == 'false') return false\n  if (/^\\d+$/.test(val)) {\n    return parseInt(val, 10)\n  }\n  return val\n}\n\n/**\n * Parse the arguments part of an XML element\n * @param {string} string String to extract attributes from.\n * @param {boolean} parseValue Parse `true` and `false` values into a boolean, and numbers into integers. Default `true`.\n */\nexport const extractProps = (string, parseValue = true) => {\n  const o = {}\n  const re = new RegExp(`\\\\s+${attributeRe.source}`, 'gu')\n  ;` ${string}`.replace(re, (match, name,  doubleQuoteVal, singleQuoteVal) => {\n    const value = singleQuoteVal || doubleQuoteVal\n    const v = value === undefined ? true : value\n    const val = parseValue ? getPropValue(v) : v\n    o[name] = val\n  })\n  return o\n}\n","import { Fn, fn,\n  nullable, nonNullable,\n  optional, any,\n} from './tokens'\n\n/**\n * Splits the string into tokens.\n * @param {string} s\n */\nexport const lex = (s) => {\n  const res = s.split(/([!?=*(),:.<>{}|\\s+])/g)\n  return res\n    .filter(a => /\\S/.test(a))\n    .map((a) => {\n      switch (a) {\n      case 'function': return fn\n      case 'Function': return Fn\n      case '!': return nonNullable\n      case '?': return nullable\n      case '=': return optional\n      case '*': return any\n      }\n      return a\n    })\n}\n\nexport function parser(tokens) {\n  let c = 0\n\n  const peek = () => tokens[c]\n  const peekNext = (n = 1) => tokens[c + n]\n  const consume = () => tokens[c++]\n\n  const parseFunction = () => {\n    /** @type {_typedefsParser.FunctionType} */\n    const meta = { return: null, args: [] }\n    if (peek() != '(') throw new Error('Expecting opening (')\n    consume()\n    let foundArgs\n    while(peek() != ')') {\n      if (foundArgs && peek() == 'this')\n        throw new Error('this must come first in function arguments')\n      if (foundArgs && peek() == 'new')\n        throw new Error('new must come first in function arguments')\n      if (peek() == 'this') {\n        consume()\n        if (peek() != ':') throw new Error('Expecting :')\n        consume()\n        meta.this = parseType()\n      } else if (peek() == 'new') {\n        consume()\n        if (peek() != ':') throw new Error('Expecting :')\n        consume()\n        meta.new = parseType()\n      } else if (peek() == '.' && peekNext() == '.' && peekNext(2) == '.') {\n        consume()\n        consume()\n        consume()\n        const type = parseType()\n        if (peek() != ')') throw new Error('Variable args must come last')\n        meta.variableArgs = type\n      } else {\n        const arg = parseType()\n        meta.args.push(arg)\n        if (peek() == '=') {\n          arg.optional = true\n          consume()\n        }\n      }\n      foundArgs = true\n      if (peek() == ')') {\n        break\n      }\n      if (peek() == ',') consume()\n      else throw new Error('Expecting , between arguments')\n    }\n    consume()\n\n    if (peek() == ':') {\n      consume()\n      const ret = parseType()\n      if (ret.name == undefined && ret.nullable)\n        // special case\n        ret.name = ''\n      meta.return = ret\n    }\n    return meta\n  }\n  const parseApplication = () => {\n    const apps = []\n    while(peek() != '>') {\n      const application = parseType()\n      apps.push(application)\n      if (peek() == '>') {\n        break\n      }\n      if (peek() == ',') consume()\n      else throw new Error('Expecting , between applications')\n    }\n    consume()\n    return apps\n  }\n\n  const parseRecord = () => {\n    const props = {}\n    while(peek() != '}') {\n      const propName = peek()\n      consume()\n      props[propName] = null\n      if (peek() == ':') {\n        consume()\n        try {\n          const type = parseType()\n          props[propName] = type\n        } catch (err) {\n          err.message += `(when parsing ${propName} property)`\n          throw err\n        }\n      }\n      if(peek() == '}') {\n        consume()\n        break\n      }\n      if (peek() != ',') {\n        throw new Error(`Expecting , for record after ${propName}`)\n      }\n      consume()\n    }\n    return props\n  }\n\n  const parseType = (specialAllowed = true, union = []) => {\n    /** @type {!_typedefsParser.Type} */\n    let type = {}\n    let applicationWithDot\n    /** @type {string} */\n    let token = peek()\n    if ([nullable, nonNullable].includes(token)) {\n      // can repeat for all specials but don't\n      if (!specialAllowed) throw new Error(`${token} not allowed after .`)\n      type.nullable = token === nullable\n      consume()\n    }\n    token = peek()\n    if (token == '(') { // union, consider cases without ()\n      consume()\n      type = {\n        ...parseType(true, []),\n        ...type, // preserve nullable\n      }\n      if (peek() != ')') throw new Error('Expecting closing )')\n      consume()\n      if (peek() != '|') {\n        return type\n      }\n    } else if (token == '{') {\n      consume()\n      type.record = parseRecord()\n      return type\n    }\n\n    if ([nonNullable, nullable].includes(token))\n      throw new Error('Nullability already defined.')\n    if (/[=),:.<>}|]/.test(token))\n      throw new Error(`Unexpected token ${token}.`)\n\n    if (peek() != '|') {\n      type.name = peek()\n      consume()\n    }\n    if (fn == token) {\n      type.function = parseFunction()\n    } else if (\n      peek() == '<' ||\n      (applicationWithDot = (peek() == '.' && peekNext() == '<'))\n    ) {\n      consume()\n      if (applicationWithDot) consume()\n      type.application = parseApplication()\n    }\n    while(peek() == '.') {\n      type.name += '.'\n      consume()\n      const { name } = parseType(false)\n      if (!name) throw new Error('Expected to see the name after .')\n      type.name += name\n    }\n    if (peek() != '|' || !specialAllowed) return type\n\n    union.push(type)\n    while(peek() == '|') {\n      consume()\n      const nextType = parseType(true, union)\n\n      // const u = nextType.union ? nextType.union : [nextType]\n      if(nextType.union !== union) union.push(nextType)\n    }\n    /** @type {!_typedefsParser.Type} */\n    const unionType = { union }\n    return unionType\n  }\n\n  return parseType()\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').Type} _typedefsParser.Type\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').FunctionType} _typedefsParser.FunctionType\n */","export const Fn = 'Function'\nexport const fn = 'function'\nexport const nullable = 'nullable'\nexport const nonNullable = 'nonNullable'\nexport const optional = '='\nexport const any = 'any'","import { lex, parser } from './lib'\n\n/**\n * The Parser For JSDoc Types.\n * @param {string} type The type to parse, e.g., `!Promise<!Array<function(string)>>`\n */\nexport default function parse(type) {\n  const tokens = lex(type)\n  return parser(tokens)\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_typedefsParser.FunctionType} FunctionType `\uff20record` The meta information about the function.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _typedefsParser.FunctionType `\uff20record` The meta information about the function.\n * @prop {!Array<!_typedefsParser.Type>} args The arguments of the function.\n * @prop {?_typedefsParser.Type} return The return type of the function. When the value is set to `null`, it means the function does not have a return. If the return was actually `null`, it would be specified as `return: { name: 'null' }`.\n * @prop {!_typedefsParser.Type} [this] The type of the `this` argument specified as `function(this: Type)`.\n * @prop {!_typedefsParser.Type} [new] The type of the `new` argument specified as `function(new: Type)`.\n * @prop {!_typedefsParser.Type} [variableArgs] The type of the variable arguments, e.g., `function(...Type)`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_typedefsParser.Type} Type `\uff20record` The representation of a type.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _typedefsParser.Type `\uff20record` The representation of a type.\n * @prop {boolean} [nullable] Whether the type is nullable. This is defined by writing `?` before the type name to state nullability and `!` otherwise. The parser does not infer nullability from types being primitive and `Function/function`.\n * @prop {string} [name] The name of the type.\n * @prop {!Array<!_typedefsParser.Type>} [union] If the type is defined as a union, e.g., `(string|number)`, contains the united types. Must include parenthesis.\n * @prop {!Object<string, _typedefsParser.Type>} [record] If the type is a record, contains its representation. If a property of the record does not have a type, it will be set to null.\n * @prop {!Array<!_typedefsParser.Type>} [application] The application of the type, e.g., the inner type of `Object<Application>`.\n * @prop {!_typedefsParser.FunctionType} [function] The function info with args and return if the type is a function.\n * @prop {boolean} [optional] If the type is returned as an optional argument of a function (`function(string=)`), this will be set to true.\n */\n","/**\n * Return a name of a property with its default value, and surrounded by square brackets if default is given. If type is boolean or number, the default value is not surrounded by \"\".\n * @param {string} name Name of the param.\n * @param {?(string|boolean|number)} [defaultValue] Default of the property.\n * @param {string} [type] Type of the param.\n * @param {string} [parentParam] Name of the parent parameter.\n * @example\n *\n * requiredParam\n * [optionalDefaultParam=false]\n * [optionalDefaultParamString=\"test\"]\n * [optionalParam]\n *\n * parentParam.requiredParam\n * [parentParam.optionalDefaultParam=false]\n * [parentParam.optionalDefaultParamString=\"test\"]\n * [parentParam.optionalParam]\n */\nexport const getNameWithDefault = (name, defaultValue, type, parentParam) => {\n  if (!name) throw new Error('The name of the property is not given')\n  const n = `${parentParam ? `${parentParam}.` : ''}${name}`\n\n  const hasDefault = defaultValue !== null\n  if (!hasDefault) return n\n\n  const isPrimitive = Number.isInteger(/** @type {number} */ (defaultValue))\n    || [true, false, 'null'].includes(defaultValue)\n    || ['number', 'boolean'].includes(type)\n  const d = isPrimitive ? defaultValue : `\"${defaultValue}\"`\n  const nn = `${n}=${d}`\n  return nn\n}\n\nexport const getPropType = ({ number, string, boolean, type }) => {\n  if (string) return 'string'\n  if (number) return 'number'\n  if (boolean) return 'boolean'\n  if (type) return type\n  return '*'\n}\n\n// update this to match what documentary has\nexport const getLink = (title, prefix = '') => {\n  const l = title\n    .replace(/<\\/?code>/g, '')\n    .replace(/<\\/?strong>/g, '')\n    .replace(/<br\\/>/g, '')\n    .replace(/&nbsp;/g, '')\n    .replace(/[^\\w-\\d ]/g, '')\n    .toLowerCase()\n    .replace(/[, ]/g, '-')\n  return `${prefix}-${l}`\n}\n\n/**\n * Prevent incorrect undefined ending.\n * @param {string} type\n */\nexport const makeOptional = (type) => {\n  let t\n  if (/[^\\w\\d._]/.test(type)) t = `(${type})`\n  else t = type\n  return `${t}|undefined`\n}\n\nexport const makeBlock = (s) => {\n  if (!s) return `/**\n */\n`\n  return `/**\n${s}\n */\n`\n}\n\nexport const addSuppress = (line) => {\n  const m = ` * @suppress {nonStandardJsDocs}\n${line}`\n  return m\n}\n\n/**\n * @param {?string} namespace\n * @param {string} name\n * @param {?string} [constr] The signature of the constructor for constructors and interfaces.\n */\nexport const getExternDeclaration = (namespace, name, constr) => {\n  const ns = namespace ? `${namespace}.` : ''\n  const v = namespace ? '' : 'var '\n  let res = `${v}${ns}${name}`\n  if (constr) res = res + ` = ${constr}`\n  return res\n}\n\n/**\n * @param {string} d\n */\nexport const trimD = d => {\n  d = d.trimRight()\n\n  const m = /\\S/.exec(d)\n  if (!m) return d\n  const i = m.index\n\n  if (i == 0) return d\n  const s = d.substr(0, i)\n  let n = s.lastIndexOf('\\n')\n  // remove everything before first /n\n  if (n == -1) n = 0\n  else {\n    n++\n    d = d.substr(n)\n  }\n  const ws = i - n\n  const w = ' '.repeat(ws)\n  const dd = d.split('\\n')\n  const a = dd.filter(b => /\\S/.test(b))\n  const notWithSpace = a.find(b => {\n    const res = !b.startsWith(w)\n    return res\n  })\n  if (!notWithSpace) {\n    const re = new RegExp(`^ {${ws}}`)\n    return dd.map(b => b.replace(re, '')).join('\\n')\n  } else return d.trim()\n}\n\n/**\n * Props\n * Args\n */\nexport const toType = (props, argsArgs) => {\n  const {\n    'async': async, 'void': Void, 'return': ret = Void ? 'void' : '',\n    ...rest\n  } = props\n  let { 'args': args = '' } = props\n\n  if (!args) {\n    args = argsArgs.map(({ fullType, name: n }) => {\n      if (n == 'this') return `${n}: ${fullType}`\n      if (n.startsWith('...')) return `...${fullType}`\n      return fullType\n    }).join(',')\n  }\n\n  let r = ret.replace(/\\n\\s*/g, ' ')\n  if (async && r) r = `!Promise<${r}>`\n  else if (async) r = '!Promise'\n  // generate function string which will be parsed\n  // a hack to convert args into _typedefParser.Type\n  let fnType = `function(${args})`\n  if (r) fnType += `: ${r}`\n  return { rest, fnType }\n  // rest['type'] = fnType // e.g., a prop will have type `function()`\n}\n","// import parse from '@typedefs/parser'\nimport extractTags from 'rexml'\nimport { trimD, getPropType } from './'\n\n/**\n * @implements {_typal.Arg}\n */\nexport default class Arg {\n  constructor() {\n    /** @type {?string} */\n    this.name = null\n    /** @type {string} */\n    this.type = ''\n    /** @type {boolean} */\n    this.optional = false\n    /** @type {string} */\n    this.description = ''\n\n    // /**\n    //  * Shows if this argument indicates the constructor type, e.g.,\n    //  * function(new: Example)\n    //  */\n    // this.isNew = false\n  }\n  fromXML(content,\n    { 'name': name, 'string': string, 'boolean': boolean, 'opt': opt, 'number': number, 'type': type },\n    rootNamespace) {\n    if (!name) throw new Error('Argument does not have a name.')\n    this.name = name\n    if (content) this.description = trimD(content)\n    let t = getPropType({ number, string, boolean, type })\n    if (rootNamespace) {\n      const s = new RegExp(`([!?])?${rootNamespace}\\\\.`, 'g')\n      t = t.replace(s, '$1')\n    }\n    if (t.endsWith('=')) {\n      t = t.replace(/=$/, '')\n      opt = true\n    }\n    this.type = t\n    if (opt) this.optional = true\n    // if (name.startsWith('...')) this.optional = true\n    // /**\n    //  * @type {_typedefsParser.Type}\n    //  */\n    // this.parsed = null\n    // try {\n    //   this.parsed = parse(this.closureType)\n    // } catch (err) { /* ok */\n    // }\n  }\n  get fullType() {\n    if (this.optional) return `${this.type}=`\n    return this.type\n  }\n  // get isParsedFunction() {\n  //   return this.parsed && this.parsed.name == 'function'\n  // }\n  // toTypescriptType() {\n  //   if (this.isParsedFunction) {\n  //     const { function: { args, return: ret } } = this.parsed\n  //     return `(${\n  //       args.map(({ name, type, optional }) => {\n  //         return `${name}${optional ? '?' : ''}: ${type}`\n  //         // return type + (optional ? '=' : '')\n  //       }).join(', ')\n  //     }) => ${ret}`\n  //   }\n  //   return this.type\n  // }\n}\n\n// /**\n//  * @param {_typedefsParser.Type} type\n//  */\n// const typeToTypescript = (type) => {\n//   const { function,   } = type\n//   return `(${\n//     args.map(({ name, type, optional }) => {\n//       return `${name}${optional ? '?' : ''}: ${type}`\n//       // return type + (optional ? '=' : '')\n//     }).join(', ')\n//   }) => ${ret}`\n// }\n\n/**\n * @param {string} content\n * @param {?string} [rootNamespace] The namespace to omit.\n */\nexport const extractArgs = (content, rootNamespace) => {\n  let ai = content.lastIndexOf('</arg>')\n  let newContent = content\n  /** @type {!Array<!Arg>} */\n  let argsArgs = []\n  if (ai != -1) {\n    ai = ai + '</arg>'.length\n    const pre = content.slice(0, ai)\n    newContent = content.slice(ai)\n    argsArgs = extractTags('arg', pre)\n    argsArgs = argsArgs.map(({ content: ac, props: ap }) => {\n      const ar = new Arg()\n      ar.fromXML(ac, ap, rootNamespace)\n      return ar\n    })\n  }\n  return { newContent, argsArgs }\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('@typedefs/parser').Type} _typedefsParser.Type\n */","import parse from '@typedefs/parser'\nimport { getPropType, getNameWithDefault, makeOptional, trimD } from './'\nimport Arg from './Arg' // eslint-disable-line\nimport serialise from './serialise'\n\n/**\n * Representation of a property of a type.\n * @implements {_typal.Property}\n */\nexport default class Property {\n  /**\n   * @param {Array<!Arg>} [args] If a property was written as a function with inner\n   * <arg> elements, this array will contain parsed entries.\n   */\n  constructor(args = null) {\n    /**\n     * The name of the property.\n     * @suppress {checkTypes}\n     * @type {?string}\n     */\n    this.name = null\n    /**\n     * The description of the property.\n     * @type {?string}\n     */\n    this.description = null\n    /**\n     * The type of the property.\n     * @type {?string}\n     */\n    this._type = null\n    /**\n     * The override on the type in externs.\n     * @type {string}\n     */\n    this.closureType = ''\n    /**\n     * The actual `closure` attribute.\n     * @type {?string}\n     */\n    this._closure = null\n    /**\n     * The default value of the property. If the default is given as null, it will be record not as `null` but as `\"null\"` here.\n     * @type {?(string|boolean|number)}\n     */\n    this.default = null\n    /**\n     * If the property is optional.\n     * @type {boolean}\n     */\n    this.optional = false\n    /**\n     * What aliases the property has.\n     * @type {!Array<string>}\n     */\n    this.aliases = []\n\n    /**\n     * Whether to skip function params serialisation (e.g., in case it's working incorrectly).\n     */\n    this.noParams = false\n    /**\n     * The parsed type.\n     * @type {?_typedefsParser.Type}\n     */\n    this.parsed = null\n\n    this.args = args\n\n    /**\n     * Whether this property is a static method.\n     * @type {boolean}\n     */\n    this._static = false\n\n    /**\n     * If this property of a type is its constructor.\n     */\n    this.isConstructor = false\n  }\n  /**\n   * For README documentation.\n   * Serialises functions to TypeScript, e.g.,\n   * (param: string) => void\n   */\n  toTypeScriptFunction(serialiseType) {\n    if (!this.parsed) throw new Error('The property was not parsed.')\n    const { function: { args, return: ret, this: thisType, variableArgs } } = this.parsed\n    const a = args\n      .map((ar) => serialiseType(ar))\n      .map((type, i) => {\n        const { optional: argOptional } = args[i]\n        let {\n          name = `arg${i}`, optional = argOptional,\n        } = this.argsWithoutThis[i] || {}\n        name = `${name}${optional ? '?' : ''}`\n        return `${name}: ${type}`\n      })\n    if (thisType) {\n      const tt = serialiseType(thisType)\n      a.unshift(`this: ${tt}`)\n    }\n    if (variableArgs) {\n      const tt = serialiseType(variableArgs)\n      let n = '...args'\n      try {\n        n = `${this.args[this.args.length - 1].name}`\n      } catch (er) { /* */ }\n      a.push(`${n}: ${tt}[]`)\n    }\n    const j = a.join(', ')\n    const r = ret ? serialiseType(ret) : '?'\n    const typeName = `(${j}) => ${r}`\n    return typeName\n  }\n  clearNamespace(namespace, s = new RegExp(`([!?])?${namespace}\\\\.`, 'g')) {\n    if (!namespace) return\n    this.type = this.type.replace(s, '$1')\n    return s\n  }\n  /**\n   * When writing externs, this will prevent adding `.prototype`, e.g.,\n   * `Type.static` instead of `Type.prototype.static`.\n   */\n  get static() {\n    return this._static\n  }\n  static fromXML(...args) {\n    const prop = new Property()\n    prop.fromXML(...args)\n    return prop\n  }\n  /**\n   * Whether the property has the default value.\n   * @type {boolean}\n   */\n  get hasDefault() {\n    return this.default !== null\n  }\n  fromXML(content,\n    {\n      'name': name, 'string': string, 'boolean': boolean, 'opt': opt, 'number': number,\n      'type': type, 'default': def, 'closure': closure, 'alias': alias, 'aliases': aliases,\n      'noParams': noParams, 'static': Static, 'initial': initial },\n  ) {\n    if (!name) throw new Error('Property does not have a name.')\n    this.name = name\n    if (content) this.description = trimD(content)\n    const t = getPropType({ number, string, boolean, type })\n\n    if (noParams) this.noParams = noParams\n\n    if (closure) this._closure = closure\n\n    this.type = t\n\n    if (def !== undefined) this.default = def\n    else if (initial !== undefined) this.default = initial\n\n    if (opt || def !== undefined /* but not initial */) this.optional = true\n    if (alias) this.aliases = [alias]\n    if (aliases) this.aliases = aliases.split(/\\s*,\\s*/)\n\n    if (Static) this._static = true\n  }\n  get type() {\n    return this._type || '*'\n  }\n  /**\n   * Type can be overridden when removing namespace from properties.\n   */\n  set type(value) {\n    this._type = value || null\n    this.closureType = this._closure || this._type || ''\n    // can also check if closure changed or just type\n    if (!this.noParams) {\n      try {\n        this.parsed = parse(this.closureType)\n        if (this.isParsedFunction && !this.args) this.args = []\n      } catch (err) { /* ok */\n        this.parsed = null\n      }\n    }\n  }\n  /**\n   * Returns the first line of JSDoc, e.g., `{type} Description`.\n   */\n  toJSDoc(parentParam = null, closure = false, useNamespace = closure) {\n    if (!this.name) throw new Error('Property does not have a name. Has it been constructed using fromXML?')\n    const nameWithDefault = getNameWithDefault(this.name, this.optional ? this.default : null, this.type, parentParam)\n    const name = this.optional ? `[${nameWithDefault}]` : nameWithDefault\n    const { descriptionWithDefault } = this\n    const t = descriptionWithDefault ? ` ${descriptionWithDefault}` : ''\n\n    const type = this.getTypedefType(closure, useNamespace)\n    const s = `{${type}} ${name}${t}`\n    return s\n  }\n  get descriptionWithDefault() {\n    let s = this.description || ''\n    const d = this.hasDefault ? `${/``` */.test(this.description) ? '\\n' :\n      (s ? ' ' : '')}Default \\`${this.default}\\`.` : ''\n    return `${s}${d}`\n  }\n  toProp(closure = false, useNamespace = closure) {\n    const jsdoc = this.toJSDoc(null, closure, useNamespace)\n    const t = indentWithAster(jsdoc, true)\n    const p = ` * @prop ${t}`\n    return p\n  }\n  /**\n   * If the property is function, returns the heading above it for jsdoc.\n   */\n  toHeading() {\n    const pp = []\n    const { function: { args, return: ret, variableArgs, this: thisType } } = this.parsed\n    const a = args.map(ar => serialise(ar))\n    a.forEach((s, i) => {\n      const { optional } = args[i]\n      const { name = `arg${i}`, description } = this.args[i] || {}\n      const arg = optional ? `[${name}]` : name\n      const d = description ? ` ${description}` : ''\n\n      pp.push(` * @param {${s}${optional ? '=' : ''}} ${arg}${d}`)\n    })\n    if (variableArgs) pp.push(` * @param {...${serialise(variableArgs)}} args`)\n    if (thisType) pp.push(` * @this {${serialise(thisType)}}`)\n\n    if (ret && ret.name != 'void') { // vs code assumes void with no return\n      const r = serialise(ret)\n      pp.push(` * @return {${r}}`)\n    }\n    return pp\n  }\n  /**\n   * When args are assigned, this returns the array without the first arg.\n   */\n  get argsWithoutThis() {\n    let argsWithoutThis = this.args\n    if (this.args && this.args[0] && this.args[0].name == 'this') {\n      const [, ...args] = this.args\n      return args\n    }\n    return argsWithoutThis\n  }\n  /**\n   * Generates string to append to methods when assigning to variables in externs.\n   * Only works for functions.\n   * E.g., `= function(arg1, arg2) {}`.\n   */\n  toExternsAssignment() {\n    if (this.isParsedFunction) {\n      const { function: { args, variableArgs } } = this.parsed\n      const a = args.map((_, i) => {\n        const { name = `arg${i}` } = this.argsWithoutThis[i] || {}\n        return name\n      })\n      if (variableArgs) a.push('...args')\n      return ` = function(${a.join(', ')}) {}`\n    } else if (this.type.startsWith('function(')) { // if couldn't parse\n      return ' = function() {}'\n    }\n    return ''\n  }\n  get isParsedFunction() {\n    return !!this.parsed && this.parsed.name == 'function'\n  }\n  /**\n   * Create type for VSCode.\n   * Used to generate types of **functions**, e.g., when the property is `function` or `fn`.\n   * If closure FLAG was set, it will override it.\n   * @param {boolean} [closure]\n   * @param {boolean} [useNamespace]\n   */\n  getTypedefType(closure = false, useNamespace = closure) {\n    if (closure) return this.closureType\n    if (!this.isParsedFunction) return this.type\n\n    return this.toTypeScriptFunction(serialise)\n  }\n  toExtern(ws = '') {\n    let pp = []\n    const { descriptionWithDefault } = this\n    if (descriptionWithDefault) {\n      const d = indentWithAster(descriptionWithDefault)\n      pp.push(d)\n    }\n    if (!this.optional && this.isParsedFunction) {\n      const lines = this.toHeading()\n      pp.push(...lines)\n    } else {\n      const t = this.optional ? makeOptional(this.closureType) : this.closureType\n      pp.push(` * @type {${t}}`)\n    }\n    if (ws) pp = pp.map(p => `${ws}${p}`)\n    return pp.join('\\n')\n  }\n  toParam(parentParam, ws = '', closure = false, useNamespace = false) {\n    const s = this.toJSDoc(parentParam, closure, useNamespace)\n    const [firstLine, ...rest] = s.split('\\n')\n    const m = [`@param ${firstLine}`, ...rest].map(l => `${ws} * ${l}`)\n    const p = m.join('\\n')\n    return p\n  }\n  makeAlias(name) {\n    const clone = /** @type {!Property} */ (Object.assign(Object.create(Object.getPrototypeOf(this)), this))\n    clone.description = `An alias for \\`${this.name}\\`.`\n    clone.name = name\n    return clone\n  }\n}\n\nconst indentWithAster = (description, skipFirst = false) => {\n  const d = description.split('\\n').map((l, i) => {\n    if (skipFirst && !i) return l\n    let s = ' *'\n    if (l.length) s += ' '\n    s += l\n    return s\n  }).join('\\n')\n  return d\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('@typedefs/parser').Type} _typedefsParser.Type\n */","import parse from '@typedefs/parser'\nimport { getLink } from './'\n\n/**\n * Iterates through the types to find the referenced one, and returns a string which contains a link to it.\n * @param {!Array<!_typal.Type>} allTypes\n * @param {string|!_typedefsParser.Type} type\n * @param {!_typal.LinkingOptions} [opts]\n */\nexport const getLinks = (allTypes, type, opts = {}) => {\n  let parsed\n  if (typeof type == 'object') parsed = type\n  else try {\n    parsed = parse(type) // should parse type when added\n    if (!parsed) {\n      console.log('Could not parse %s', type)\n    }\n  } catch (err) {\n    console.log('Could not parse %s', type)\n    console.error(err.message)\n  }\n  if (!parsed) return type\n  const s = parsedToString(parsed, allTypes, opts)\n  return s\n}\n\n/**\n * @param {!_typedefsParser.Type} type\n * @param {!Array<!_typal.Type>} allTypes\n * @param {!_typal.LinkingOptions} opts\n */\nexport const parsedToString = (type, allTypes, opts = {}) => {\n  if (type.name == '' && type.nullable) return '?' // special case\n  const { escapePipe = true } = opts\n  let s = ''\n  let nullable = ''\n  if (type.nullable) nullable = '?'\n  else if (type.nullable === false) nullable = '!'\n  const p2s = (arg) => parsedToString(arg, allTypes, opts)\n\n  if (type.function) {\n    s += nullable\n    s += type.name + '(' // Function or function\n    const args = []\n    if (type.function.this) {\n      let t = 'this: '\n      t += p2s(type.function.this)\n      args.push(t)\n    }\n    if (type.function.new) {\n      let t = 'new: '\n      t += p2s(type.function.new)\n      args.push(t)\n    }\n    type.function.args.forEach((a) => {\n      let t = p2s(a)\n      if (a.optional) t += '='\n      args.push(t)\n    })\n    if (type.function.variableArgs) {\n      let t = '...'\n      t += p2s(type.function.variableArgs)\n      args.push(t)\n    }\n    const argsJoined = args.join(', ')\n    s += argsJoined + ')'\n    if (type.function.return) {\n      s += ': ' + p2s(type.function.return)\n    }\n  } else if (type.record) {\n    s += '{ '\n    const rs = Object.keys(type.record).map((key) => {\n      const val = type.record[key]\n      if (!val) return key\n      const v = p2s(val)\n      return `${key}: ${v}`\n    })\n    s += rs.join(', ')\n    s += ' }'\n  } else if (type.application) {\n    s += getTypeWithLink(/** @type {string} */ (type.name), allTypes, nullable, opts) + '&lt;'\n    const apps = type.application.map((a) => {\n      return p2s(a)\n    })\n    s += apps.join(', ')\n    s += '&gt;'\n  } else if (type.union) {\n    s += nullable\n    s += '('\n    const union = type.union.map((u) => {\n      return p2s(u)\n    })\n    s += union.join(escapePipe ? ' \\\\| ' : ' | ')\n    s += ')'\n  } else {\n    const name = type.name == 'any' ? '*' : type.name\n    s += getTypeWithLink(/** @type {string} */ (name), allTypes, nullable, opts)\n  }\n  return s\n}\n\n/**\n * The function which generates a link for the type.\n * @param {string} type\n * @param {!Array<!_typal.Type>} allTypes\n * @param {!_typal.LinkingOptions} [opts]\n */\nconst getTypeWithLink = (type, allTypes, nullable = '', opts = {}) => {\n  const { flatten = false, nameProcess,\n    link: linkFn = ({ link: l }) => `#${l}` } = opts\n  const l = getLinkToType(allTypes, type)\n  const n = `${nullable}${type}`\n  if (!l) return n\n  let { link, type: { description } } = l\n  link = linkFn(l)\n  if (flatten) {\n    const found = allTypes.find(({ fullName }) => fullName == type)\n    if (found && found.link) {\n      link = found.link\n    }\n    if (!description && found.description) description = found.description\n    if (typeof flatten == 'function') flatten(type)\n  }\n  const nn = nameProcess ? nameProcess(n) : n\n  if (!description) return `[${nn}](${link})`\n  return `<a href=\"${link}\" title=\"${description.replace(/\"/g, '&quot;')}\">${nn}</a>`\n  // const typeWithLink = `[${n}](#${link})`\n  // return typeWithLink\n}\n\n// const li = (p) => {\n//   return p.replace(/(^\\s*)- (.+)$/mg, `$1<li>$2</li>`)\n// }\n\n\n/**\n * @param {!Array<!_typal.Type>} allTypes\n * @param {string} type\n */\nconst getLinkToType = (allTypes, type) => {\n  const linkedTypes = allTypes.filter(({ fullName }) => fullName == type)\n  if (!linkedTypes.length) return\n\n  // in case we're importing local types and imports have same names\n  const importType = linkedTypes.find(({ import: i }) => i || false)\n  const actualType = linkedTypes.find(({ import: i }) => !i)\n\n  let linkedType = actualType || importType\n\n  const link = getLink(linkedType.fullName, 'type')\n  return { link, type: linkedType }\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../types').Type} _typal.Type\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../types').LinkingOptions} _typal.LinkingOptions\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('@typedefs/parser').Type} _typedefsParser.Type\n */","import { getLinks } from './get-links'\n\n/**\n * @param {!_typal.Type} type The type for which to make the table\n * @param {!Array<!_typal.Property>} [props]\n * @param {!Array<!_typal.Type>} [allTypes]\n * @param {!_typal.ToMarkdownOptions} [opts]\n */\nexport default function makePropsTable (type, props = [], allTypes = [], opts = {}) {\n  const { narrow = false, flatten = false, preprocessDesc, link } = opts\n  if (!props.length) return ''\n  const constr = type.isConstructor || type.isInterface\n  const anyHaveDefault = props.some(({ hasDefault }) => hasDefault)\n\n  const linkOptions = /** @type {!_typal.LinkingOptions} */ ({\n    flatten,\n    escapePipe: !narrow,\n    link,\n  })\n  const links = (s) => getLinks(/** @type {!Array<!_typal.Type>} */ (allTypes), s, linkOptions)\n  const ps = props.map((prop) => {\n    let typeName\n    if (prop.args && prop.isParsedFunction) {\n      typeName = prop.toTypeScriptFunction(links)\n      if (prop.isConstructor) typeName = `new ${typeName}`\n    } else\n      typeName = links(prop.parsed || prop.type)\n    // constructors and interfaces will always have to initialise properties\n    // their `this` properties in the constructor.\n    const name = (constr || prop.optional) ? prop.name : `${prop.name}*`\n    const d = !prop.hasDefault ? '-' : `\\`${prop.default}\\``\n    const de = preprocessDesc ? preprocessDesc(prop.description) : prop.description\n    return {\n      prop,\n      typeName,\n      name,\n      de: esc(de, !narrow),\n      d,\n    }\n  })\n  if (narrow) { // narrow is the newer API for Documentary\n    return { props: ps, anyHaveDefault, constr }\n  }\n  const ar = ps.map(({\n    name, typeName, de, d, prop,\n  }) => {\n    const n = prop.optional ? name : `__${name}__`\n    return [n, `<em>${typeName}</em>`, de, ...(anyHaveDefault ? [d] : [])]\n  })\n\n  const h = ['Name',\n    ...(narrow ? ['Type & Description'] : ['Type', 'Description']),\n    ...(anyHaveDefault ? [constr ? 'Initial' : 'Default'] : [])]\n\n  const j = JSON.stringify([h, ...ar], null, 2)\n  return `\n\n\\`\\`\\`table\n${j}\n\\`\\`\\``\n}\n\nconst esc = (s = '', escapePipe = true) => {\n  if (s === null) s = ''\n  if (escapePipe) {\n    s = s.replace(/\\|/g, '\\\\|')\n  }\n  return s\n    .replace(/</g, '&lt;')\n    .replace(/>/, '&gt;')\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../types').Type} _typal.Type\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../types').Property} _typal.Property\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../types').ToMarkdownOptions} _typal.ToMarkdownOptions\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../types').LinkingOptions} _typal.LinkingOptions\n */\n","import extractTags from 'rexml'\nimport Property from './Property'\nimport { addSuppress, makeBlock, getExternDeclaration, makeOptional, toType } from './'\nimport { trimD } from './'\nimport Arg, { extractArgs } from './Arg' // eslint-disable-line\nimport { getLinks } from './get-links'\nimport makePropsTable from './make-props-table'\n\n/**\n * A representation of a type.\n * @implements {_typal.Type}\n */\nexport default class Type {\n  constructor() {\n    /**\n     * The name of the type.\n     * @type {string}\n     */\n    this.name = ''\n    /** @type {?string} */\n    this.type = null\n    /**\n     * An overriding type for closure to generate externs, e.g.,\n     * `function(string): boolean` instead of `(s:string) => boolean`.\n     * @type {?string}\n     * @deprecated\n     */\n    this.closureType = null\n    /** @type {?string} */\n    this.description = null\n    /** @type {boolean} */\n    this.noToc = false\n    /** @type {boolean} */\n    this.spread = false\n    /** @type {boolean} */\n    this.noExpand = false\n    /** @type {?string} */\n    this.link = null\n    /** @type {!Array<!Property>} */\n    this.properties = []\n    /**\n     * The type's namespace, e.g., `typal`.\n     * @type {?string}\n     */\n    this.namespace = null\n    /**\n     * @type {boolean}\n     * Whether the externs should have the form of\n```js\n/\uff0a\uff0a @constructor \uff0a/\n_ns.Type\n/\uff0a\uff0a @boolean \uff0a/\n_ns.Type.prototype.isConstructor\n```\n     */\n    this.isConstructor = false\n    /**\n     * @type {boolean}\n     * Same as `constructor`, but with `@interface` annotation.\n     */\n    this.isInterface = false\n\n    /**\n     * @type {boolean}\n     * Same as `constructor`, but with `@record` annotation.\n     */\n    this.isRecord = false\n    /**\n     * Types `@constructor`, `@interface` and `@record` can inherit properties from other types using `@extends`.\n     * @see https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler#extends-type\n     * @type {?string}\n     */\n    this.extends = null\n\n    /**\n     * @type {Array<!Arg>}\n     */\n    this.args = null\n  }\n  get import() {\n    return false\n  }\n  /**\n   * Create type from the xml content and properties parsed with `rexml`.\n   */\n  fromXML(content, {\n    'name': name, 'type': type, 'desc': desc, 'noToc': noToc, 'spread': spread,\n    'noExpand': noExpand, 'link': link, 'closure': closure,\n    'constructor': isConstructor, 'extends': ext, 'interface': isInterface,\n    'record': isRecord,\n  }, namespace, rootNamespace = null) {\n    if (!name) throw new Error('Type does not have a name.')\n    this.name = name\n\n    if (type) this.type = type\n    if (closure) this.closureType = closure\n    else this.closureType = this.type\n    if (desc) this.description = trimD(desc)\n    this.noToc = !!noToc\n    this.spread = !!spread\n    this.noExpand = !!noExpand\n    if (link) this.link = link\n    if (isConstructor === true) this.isConstructor = isConstructor\n    if (isInterface === true) this.isInterface = isInterface\n    if (isRecord === true) this.isRecord = isRecord\n    if (ext) this.extends = ext\n\n    if (content) {\n      const ps = extractTags('prop', content)\n      const props = ps.map(({ content: c, props: p }) => {\n        const pr = new Property()\n        pr.fromXML(c, p)\n        return pr\n      })\n      const functions = extractTags(['function', 'fn', 'static'], content)\n\n      const fnProps = functions.map(({ content: c, props: p, tag }) => {\n        const isStatic = tag == 'static'\n        const { newContent, argsArgs } = extractArgs(c, rootNamespace)\n\n        const pr = new Property(argsArgs)\n        const { rest, fnType } = toType(p, argsArgs)\n        rest['type'] = fnType\n\n        pr.fromXML(newContent, rest)\n        if (isStatic) pr._static = true\n        return pr\n      })\n      const all = [...props, ...fnProps]\n      const { s, n } = all.reduce((acc, p) => {\n        if (p.static) acc.s.push(p)\n        else acc.n.push(p)\n        return acc\n      }, { s: [], n: [] })\n      this.properties = [...s, ...n]\n    }\n    if (namespace) this.namespace = namespace\n  }\n  get shouldPrototype() {\n    return this.isConstructor || this.isInterface || this.isRecord\n  }\n  /**\n   * When printing to externs, this is the right-hand part.\n   * Used in constructors, interfaces.\n   * @example\n   * _ns.Type = function(paramA, paramB)\n   * @param {!Array<!Arg>} array The parsed arguments\n   */\n  // * @param {string} string The inner arguments part as string\n  setAssignment(array) {\n    // this._assignmentString = string\n    this.args = array\n  }\n  toExtern() {\n    let s\n    if (this.closureType) { //  && !(this.isConstructor || this.isInterface)\n      s = ` * @typedef {${this.closureType}}`\n    } else if (!this.shouldPrototype) {\n      const nn = getSpread(this.properties, true)\n      s = ` * @typedef {${nn}}`\n    }\n    if (s) {\n      if (this.description) s = ` * ${this.description}\\n${s}`\n      s = makeBlock(s)\n      s = s + getExternDeclaration(this.namespace, this.name)\n      return s\n    }\n    // constructor\n    return this.toPrototype()\n  }\n  /**\n   * @param {boolean} [useNamespace=false]\n   */\n  getFullNameForExtends(useNamespace = false) {\n    const name = `${this.extends ? '$' : ''}${this.name}`\n    const n = useNamespace ? `${this.ns}${name}` : name\n    return n\n  }\n  getTypedefType() {\n    return 'Object'\n  }\n  /**\n   * Removes the namespace from the type.\n   * @param {string} rootNamespace\n   * @param {!RegExp} [s] Constructed regex.\n   */\n  clearNamespace(rootNamespace, s = new RegExp(`([!?])?${rootNamespace}\\\\.`, 'g')) {\n    if (this.type) this.type = this.type.replace(s, '$1')\n    if (this.extends) this.extends = this.extends.replace(s, '$1')\n    return s\n  }\n  /**\n   * Used to generate typedefs, but not externs.\n   * This covers both when extending and when not.\n   * @param {boolean} [closure=false]\n   * @param {boolean} [noSuppress=false]\n   * @param {boolean} [useNamespace=false]\n   */\n  toNaturalTypedef(closure = false, noSuppress = false, useNamespace = closure) {\n    const t = (closure ? this.closureType : this.type) || this.getTypedefType()\n    const dd = ` ${this.getFullNameForExtends(useNamespace)}${this.descriptionWithTag}`\n    const s = ` * @typedef {${t}}${dd}`\n    /**\n     * @type {!Array<!Property>}\n     */\n    const properties = this.properties ? this.properties.reduce((acc, p) => {\n      if (p._static) return acc\n      acc.push(p)\n      const a = p.aliases.map(al => p.makeAlias(al))\n      acc.push(...a)\n      return acc\n    }, []) : []\n    const p = properties.map((pr) => {\n      const sp = pr.toProp(closure, useNamespace)\n      return sp\n    })\n    let typedef = [s, ...p].join('\\n')\n    if (closure && !noSuppress) typedef = addSuppress(typedef)\n    typedef = makeBlock(typedef)\n    return typedef\n  }\n  get descriptionWithTag() {\n    const d = this.description ? ` ${this.description}` : ''\n    const t = this.tag ? ` \\`\uff20${this.tag}\\`` : ''\n    return `${t}${d}`\n  }\n  /**\n   * Generate `@typedef` block comment for the type.\n   * @param {boolean} [closure=false]\n   * @param {boolean} [noSuppress=false]\n   * @param {boolean} [useNamespace=false]\n   */\n  toTypedef(closure = false, noSuppress = false, useNamespace = closure) {\n    const hasExtends = !!this.extends\n    const natural = this.toNaturalTypedef(closure, noSuppress, useNamespace)\n\n    const parts = []\n    // need this to be able to import types from other programs,\n    // /\u204e\u204e\n    //  \u204e @typedef {ns.Type} Type The type (that can be imported)\n    //  \u204e @typedef {Object} ns.Type The type (to use in current file)\n    //  \u204e/\n    // let pre = ''\n\n    if (this.namespace && closure) {\n      let td = ` * @typedef {${this.fullName}} ${this.name}${this.descriptionWithTag}`\n      if (closure && !noSuppress) td = addSuppress(td)\n      td = makeBlock(td)\n      parts.push(td)\n    } else if (this.namespace && useNamespace) {\n      let td = ` * @typedef {${this.fullName}} ${this.name}${this.descriptionWithTag}`\n      td = makeBlock(td)\n      parts.push(td)\n    }\n    if (hasExtends) {\n      let extended = ` * @typedef {${this.extends} & ${this.getFullNameForExtends(useNamespace)}} ${useNamespace ? this.fullName : this.name}${this.descriptionWithTag}`\n      if (closure && !noSuppress) extended = addSuppress(extended)\n      extended = makeBlock(extended)\n      parts.push(extended)\n    }\n    parts.push(natural)\n\n    return parts.join('')\n  }\n  get prototypeAnnotation() {\n    const tag = this.tag\n    if (!tag)\n      throw new Error('Unknown prototype type (not constructor or interface).')\n    return tag\n  }\n  get tag() {\n    if (this.isConstructor) return 'constructor'\n    if (this.isInterface) return 'interface'\n    if (this.isRecord) return 'record'\n    return ''\n  }\n\n  /**\n   * To heading above declaration bodies. Can be used in externs.\n   */\n  toHeading(ws = '', includePrototypeTag = true) {\n    let lines = []\n    if (this.description) lines.push(` * ${this.description}`)\n    if (this.extends) lines.push(` * @extends {${this.extends}}`)\n    if (this.args) this.args.forEach((s) => {\n      let { name, description, optional, type } = s\n      const d = description ? ` ${description}` : ''\n      if (name.startsWith('...')) {\n        name = name.slice(3)\n        type = `...${type}`\n      } else if (name == 'this') {\n        lines.push(` * @this {${type}}${d}`)\n        return\n      }\n      const arg = optional ? `[${name}]` : name\n\n      lines.push(` * @param {${type}${optional ? '=' : ''}} ${arg}${d}`)\n    })\n    if (includePrototypeTag) lines.push(` * @${this.prototypeAnnotation}`)\n    if (ws) lines = lines.map(p => `${ws}${p}`)\n    return lines\n  }\n  /**\n   * Used to place interfaces/constructor declarations in externs.\n   */\n  toExternsAssignment() {\n    return this.args ? `function(${\n      this.args\n        .filter(({ name }) => name != 'this')\n        .map(({ name }) => name)\n        .join(', ')\n    }) {}` : null\n  }\n  /**\n   * Only used in externs.\n   */\n  toPrototype() {\n    const pp = this.toHeading()\n    // if (this.closureType) pp.push(` * @type {${this.closureType}}`)  // todo <arg>new</arg>\n    let s = makeBlock(pp.join('\\n'))\n    s = s + getExternDeclaration(this.namespace, this.name, this.toExternsAssignment())\n    /** @type {!Array<!Property>} */\n    const properties = this.properties.reduce((acc, p) => {\n      acc.push(p)\n      const a = p.aliases.map(al => p.makeAlias(al))\n      acc.push(...a)\n      return acc\n    }, [])\n    const t = properties.filter(({ isConstructor }) => !isConstructor).map((p) => {\n      let r = p.toExtern()\n      r = makeBlock(r)\n      const prototype = p.static ? '' : '.prototype'\n      r = r + getExternDeclaration(`${this.fullName}${prototype}`,\n        /** @type {string} */ (p.name))\n      r += p.toExternsAssignment()\n      return r\n    })\n    const j = [s, ...t].join('\\n')\n    return j\n  }\n  /**\n   * The namespace.\n   */\n  get ns() {\n    if (this.namespace) return `${this.namespace}.`\n    return ''\n  }\n  get fullName() {\n    return `${this.ns}${this.name}`\n  }\n  /**\n   * Makes JSDoc for a function.\n   * @param {string} paramName The name of the argument.\n   * @param {boolean|undefined} optional Whether the argument is optional (wrapped in [argument])\n   * @param {string} ws The whitespace prior to the param.\n   * @param {boolean|undefined} nullable Whether the argument had ! or ?.\n   * @param {boolean} [closure]\n   * @param {boolean} [useNamespace]\n   */\n  toParam(paramName, optional, ws, nullable, closure = false, useNamespace = false) {\n    let n = ''\n    if (nullable === true) n = '?'\n    else if (nullable === false) n = '!'\n    const d = this.description ? ` ${this.description}` : ''\n    const nn = this.spread ? getSpread(this.properties) : (closure || useNamespace ? this.fullName : this.name)\n    const pn = optional ? `[${paramName}]` : paramName\n    const s = `${ws || ''} * @param {${n}${nn}} ${pn}${d}`\n    const p = this.properties && !this.noExpand ? this.properties.map((pr) => {\n      const sp = pr.toParam(paramName, ws, closure, useNamespace)\n      return sp\n    }) : []\n    const st = [s, ...p].join('\\n')\n    return st\n  }\n\n  /**\n   * Converts a type to a markdown string.\n   * @param {!Array<!Type>} [allTypes]\n   * @param {!_typal.ToMarkdownOptions} [opts]\n   * @todo open-details\n   */\n  toMarkdown(allTypes = [], opts = {}) {\n    const { flatten, details = /** @type {!Array<string>} */ ([]) } = opts\n    const displayInDetails = details.includes(this.name)\n    const t = this.type ? `\\`${this.type}\\`` : ''\n    let typeWithLink = t, useCode = false\n    if (this.link) {\n      typeWithLink = `[${t}](${this.link})`\n    } else if (!this.import && this.type) {\n      typeWithLink = getLinks(allTypes, this.type, opts)\n      useCode = typeWithLink != this.type\n      typeWithLink = wrapCode(typeWithLink, useCode)\n    }\n    const codedName = wrapCode(this.fullName)\n    let nn\n    if (!this.import) {\n      nn = this.noToc ? `[${codedName}](l-type)` : `[${codedName}](t-type)`\n    } else {\n      nn = `[${codedName}](l-type)`\n    }\n    const d = this.description ? `: ${this.description}` : ''\n    const twl = typeWithLink ? `${typeWithLink} ` : ''\n    let LINE = twl // `${twl}<strong>${nn}`\n    let useTag = /_/.test(nn)\n    if (this.extends) {\n      let e = `\\`${this.extends}\\``\n      const foundExt = allTypes.find(({ fullName }) => {\n        return fullName == this.extends\n      })\n      if (foundExt && foundExt.link) {\n        e = '<a '\n        if (foundExt.description) {\n          e += `title=\"${foundExt.description}\" `\n        }\n        e += `href=\"${foundExt.link}\">\\`${this.extends}\\`</a>`\n      } else {\n        const le = getLinks(allTypes, this.extends, { ...opts,\n          nameProcess: (td) => `\\`${td}\\``,\n        })\n        if (this.extends != le) e = le\n      }\n      const extendS = ` extends ${e}`\n      useTag = useTag || /_/.test(e)\n      if (useTag) LINE += '<strong>'\n      else LINE += '__'\n      LINE += nn + extendS\n      if (typeof flatten == 'function') flatten(this.extends)\n    } else {\n      if (useTag) LINE += '<strong>'\n      else LINE += '__'\n      LINE += nn\n    }\n    if (useTag) LINE += '</strong>'\n    else LINE += '__'\n    LINE += d\n    const table = makePropsTable(this, this.properties, allTypes, opts)\n    // delegate rendering to documentary\n    return { LINE, table, displayInDetails }\n  }\n}\n\nconst wrapCode = (s, useCode = false) => {\n  return `${useCode ? '<code>' : '`'}${s}${useCode ? '</code>' : '`'}`\n}\n\n/**\n * @param {!Array<!Property>} [properties]\n * @param {boolean} [closure = false] Whether generate for Closure's externs.\n */\nconst getSpread = (properties = [], closure = false) => {\n  properties = properties.reduce((acc, p) => {\n    acc.push(p)\n    const extra = p.aliases.map((a) => {\n      return { ...p, name: a }\n    })\n    acc.push(...extra)\n    return acc\n  }, [])\n  const s = properties.map(p => {\n    const type = closure ? p.closureType : p.type\n    let n = p.name, t = type\n    if (p.optional && !closure) {\n      n = `${p.name}?`\n    } else if (p.optional && closure) {\n      t = `(${makeOptional(type)})`\n    }\n    const st = `${n}: ${t}`\n    return st\n  })\n  const j = s.join(', ')\n  const st = `{ ${j} }`\n  return st\n}\n\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('@typedefs/parser').Type} _typedefsParser.Type\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../types').ToMarkdownOptions} _typal.ToMarkdownOptions\n */\n\n// /**\n//  * The function\n//  * @param {(a: string, b?:string) => void} ab\n//  */\n// const a = (ab) => {\n\n// }","import Type from './Type'\nimport { trimD } from './'\n\n/**\n * @implements {_typal.Method}\n */\nexport default class Method extends Type {\n  constructor() {\n    super()\n    /** @type {?string} */\n    this._methodReturn = null\n    /** @type {boolean} */\n    this.async = false\n  }\n  /**\n   * Make sure to define as `typedef` in externs\n   */\n  get shouldPrototype() {\n    return false\n  }\n  get isMethod() {\n    return true\n  }\n  fromXML(content, { 'async': methodAsync, 'return': methodReturn,\n    ...props\n  }, ...args) {\n    this.description = trimD(content)\n    super.fromXML('', props, ...args)\n    if (methodReturn) this._methodReturn = methodReturn.replace(/\\n\\s*/g, ' ')\n    if (methodAsync) this.async = true\n  }\n  /**\n   * If the `return` was set on type, this will return it.\n   */\n  get return() {\n    return this._methodReturn || 'void'\n  }\n  /**\n   * Same as type, but adds the return.\n   */\n  toHeading(ws = '') {\n    const lines = super.toHeading(ws, false)\n    let r\n    if (this._methodReturn) r = this.return\n    if (this.async && r) r = `Promise<${r}>`\n    else if (this.async) r = 'Promise'\n    if (r) lines.push(`${ws} * @return {${r}}`)\n\n    return lines\n  }\n  /**\n   * TypeScript-style type for typedefs.\n   */\n  getTypedefType() {\n    return `(${\n      this.args.map(({ name, type, optional }) => {\n        return `${name}${optional ? '?' : ''}: ${type}`\n        // return type + (optional ? '=' : '')\n      }).join(', ')\n    }) => ${this.return}`\n  }\n  clearNamespace(rootNamespace) {\n    const s = super.clearNamespace(rootNamespace)\n    if (this._methodReturn) this._methodReturn = this._methodReturn.replace(s, '$1')\n  }\n}","import Type from './Type'\nimport { trimD } from './'\n\n/**\n * The representation of a parsed import.\n * @implements {_typal.Import}\n */\nexport default class Import extends Type {\n  constructor() {\n    super()\n    /**\n     * The package name name from where to import.\n     * @type {string}\n     */\n    this.from = ''\n  }\n  get import() {\n    return true\n  }\n  fromXML(content, {\n    'from': from, 'name': name, ...props\n  }, namespace, rootNamespace) {\n    if (!from) throw new Error('From attribute of import is not given.')\n    this.from = from\n    this.description = trimD(content)\n\n    super.fromXML('', {\n      ...props, 'noToc': true, name,\n      type: `import('${from}').${name}`,\n    }, namespace != rootNamespace ? namespace : null)\n  }\n  toTypedef(includeNamespace = true) {\n    const n = includeNamespace ? this.fullName : this.name\n    return ` * @typedef {import('${this.from}').${this.name}} ${n}`\n  }\n}","export default os\nexport const {\n  EOL,\n  arch,\n  constants,\n  cpus,\n  endianness,\n  freemem,\n  homedir,\n  hostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release,\n  tmpdir,\n  totalmem,\n  type,\n  uptime,\n  userInfo,\n} = os","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.JS lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {!_cleanStack.Config} [options] Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {!Array<string>} [options.ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\nconst cleanStack = (stack, options) => {\n  const {\n    pretty = false, ignoredModules = ['pirates'],\n  } = options || {}\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim())\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_cleanStack.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _cleanStack.Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {!Array<string>} [ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\n","import extractTags from 'rexml'\nimport Type from './Type'\nimport Method from './Method'\nimport Import from './Import'\nimport read from '@wrote/read'\nimport Arg, { extractArgs } from './Arg' // eslint-disable-line\nimport Property from './Property'\nimport { toType } from './'\n\n/**\n * When Documentary compiles types with `-n` (root namespace) flag,\n * the namespace needs to be cleared.\n * @param {string} namespace\n * @param {!_typal.Type} type\n */\nconst removeNamespace = (namespace, type) => {\n  const s = new RegExp(`([!?])?${namespace}\\\\.`, 'g')\n  type.properties.forEach((p) => {\n    p.clearNamespace(namespace, s)\n  })\n  type.clearNamespace(namespace)\n}\n\n/**\n * @param {Type} type\n * @param {string} [rootNamespace]\n */\nconst addConstructorProperty = (type, rootNamespace) => {\n  if (!type.args || !type.args.length) return\n  const args = type.args.map(({ fullType }) => fullType).join(', ')\n  const t = `function(${args}): ${type.fullName}`\n  const prop = new Property(type.args)\n  prop.isConstructor = true\n  prop.fromXML('Constructor method.', { 'type': t, 'name': 'constructor' })\n  prop.clearNamespace(rootNamespace)\n  type.properties.unshift(prop)\n}\n\n/**\n * Parse the types.xml file.\n * @param {string} xml The content of the `xml` file.\n * @param {string} [rootNamespace] Namespace to ignore in types and properties.\n */\nconst parseFile = (xml, rootNamespace) => {\n  const root = extractTags('types', xml)\n  if (!root.length)\n    throw new Error('XML file should contain root types element.')\n\n  const [{ content: Root, props: {\n    'namespace': ns1,\n    'ns': namespace = ns1,\n  } }] = root\n\n  const ns = rootNamespace == namespace ? undefined : namespace\n\n  const extracted = extractTags([\n    'type', 'interface', 'constructor', 'method', 'import',\n  ], Root)\n\n  /** @type {!Array<!_typal.Import>} */\n  const imports = []\n\n  const types = /** @type {!Array<!_typal.Type>} */ (extracted.reduce((acc, { content, props, tag }) => {\n    const { 'alias': alias, 'aliases': aliases, ...restProps } = props\n    const als = alias ? [alias] : (aliases ? aliases.split(/, */) : [])\n\n    switch (tag) {\n    case 'type': {\n      const type = new Type()\n      type.fromXML(content, props, ns, rootNamespace)\n      acc.push(type)\n\n      als.forEach((name) => {\n        const type2 = new Type()\n        type2.fromXML(content, { ...restProps, name }, ns, rootNamespace)\n        acc.push(type2)\n      })\n      break\n    }\n    case 'interface': {\n      const t = parseTypes(content, props, ns, rootNamespace)\n      t.forEach(tt => {\n        addConstructorProperty(tt, rootNamespace)\n        tt.isInterface = true\n      })\n      acc.push(...t)\n      break\n    }\n    case 'constructor': {\n      const t = parseTypes(content, props, ns, rootNamespace)\n      t.forEach(tt => {\n        addConstructorProperty(tt, rootNamespace)\n        tt.isConstructor = true\n      })\n      acc.push(...t)\n      break\n    }\n    case 'method': {\n      const t = parseTypes(content, props, ns, rootNamespace, true)\n      acc.push(...t)\n      break\n    }\n    /**\n     * Imports parsed into types.\n     */\n    case 'import': {\n      const im = new Import()\n      im.fromXML(content, props, props['ns'] || props['from'], rootNamespace)\n      imports.push(im)\n\n      break\n    }\n    }\n    return acc\n  }, []))\n\n  if (rootNamespace) types.forEach(t => removeNamespace(\n    /** @type {string} */ (rootNamespace), t\n  ))\n\n  return { namespace, types, imports }\n}\n\n/**\n * This should be applicable only to <interface> / <constructor> / <method>\n * @param {string} content\n * @param {Object} props\n * @param {string} [ns]\n * @param {string} [rootNamespace]\n * @param {boolean} [isMethod]\n */\nconst parseType = (content, props, ns, rootNamespace, isMethod = false) => {\n  const type = isMethod ? new Method() : new Type()\n  const i = content.search(/<(prop|function|fn|static) /)\n  let prebody = '', body = content\n  if (i != 1) {\n    prebody = content.slice(0, i)\n    body = content.slice(i)\n  }\n  const { argsArgs, newContent } = extractArgs(prebody, rootNamespace)\n\n  /** Specify args in props... disable ATM */\n  // let { 'args': args = '', ...rest } = props\n  // if (!args && argsArgs.length) {\n  //   args = argsArgs.map(({ type: at, optional }) => {\n  //     if (optional !== null) return `${at}=`\n  //     return at\n  //   }).join(',')\n  // }\n  // const assignment = `function(${args})`\n\n  type.fromXML(isMethod ? newContent : body, props, ns, rootNamespace)\n\n  const { fnType } = toType(props, argsArgs)\n  if (isMethod) type.closureType = fnType\n\n  type.setAssignment(argsArgs)\n\n  return type\n}\n\n/** @type {function(new: Property)} */\nconst a = function () {}\n\n/**\n * This is applicable to @interfaces/constructors/methods which\n * will be written with `= function () {}` in externs.\n * @param {string} content\n * @param {!Object} props\n * @param {string} [ns]\n * @param {string} [rootNamespace]\n * @param {boolean} [isMethod]\n */\nconst parseTypes = (content, props, ns, rootNamespace, isMethod = false) => {\n  const acc = []\n  const { 'alias': alias, 'aliases': aliases, ...restProps } = props\n  const type = parseType(content, props, ns, rootNamespace, isMethod)\n  acc.push(type)\n\n  const als = alias ? [alias] : (aliases ? aliases.split(/, */) : [])\n\n  als.forEach((name) => {\n    const type2 = parseType(content, { ...restProps, name }, ns, rootNamespace, isMethod)\n    type2.description = `${type2.description}${type2.description ? ' ' : ''}Alias of \\`${restProps.name}\\`.`\n    acc.push(type2)\n  })\n\n  return acc\n}\n\nexport default parseFile\n\n/**\n * @param {string} path\n */\nexport const readTypesFile = async (path, ignore = []) => {\n  const xml = await read(path)\n  let namespace, types, imports\n  try {\n    ({ namespace = null, types, imports } = parseFile(xml))\n  } catch (err) {\n    err.message = `Error while reading ${path}\\n${err.message}`\n    throw err\n  }\n  types = types.filter(({ fullName }) => {\n    if (ignore.includes(fullName)) return false\n    return true\n  })\n  imports = imports.filter(({ fullName }) => {\n    if (ignore.includes(fullName)) return false\n    return true\n  })\n  return { types, imports, namespace }\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../types').Type} _typal.Type\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../types').Import} _typal.Import\n */","import '../types/externs'\nimport { Type, Property, Method, getNameWithDefault, parseFile, getLinks } from './'\n\nmodule.exports = {\n  '_Type': Type,\n  '_Property': Property,\n  '_Method': Method,\n  '_parseFile': parseFile,\n  '_getLinks': getLinks,\n}"],
"names":["$jscomp.defineProperty","$jscomp.global","$jscomp.polyfill","mismatch","re","string","keys","m","replace","match","args","o","slice","p","length","reduce","acc","capturedGroup","i","key","undefined","start","push","attributeRe","RegExp","nameRe","source","valRe","attributesRe","extractTags","tag","matches","join","Array","isArray","tags","t","simple","end1","end2","map","res","tagName","attributes","content","attrs","trim","props","extractProps","simpleAttribute","val","test","parseInt","lex","s","split","filter","a","fn","Fn","nonNullable","nullable","optional","any","parser","tokens","c","peekNext","n","parseType","specialAllowed","union","type","token","includes","Error","propName","err","message","record","name","meta","return","foundArgs","this","new","variableArgs","arg","ret","function","applicationWithDot","apps","application","nextType","unionType","parse","getPropType","number","boolean","trimD","d","trimRight","exec","index","substr","lastIndexOf","ws","w","repeat","dd","b","find","notWithSpace","startsWith","toType","argsArgs","async","Void","rest","fullType","r","fnType","fromXML","opt","rootNamespace","description","endsWith","Arg","extractArgs","ai","newContent","pre","ac","ap","ar","def","closure","alias","aliases","noParams","Static","initial","_closure","default","_static","Property","_type","closureType","parsed","isConstructor","serialiseType","thisType","argOptional","argsWithoutThis","tt","unshift","er","j","typeName","namespace","value","isParsedFunction","getLinks","allTypes","opts","console","log","error","parsedToString","escapePipe","forEach","argsJoined","rs","Object","v","getTypeWithLink","u","flatten","nameProcess","linkFn","l","getLinkToType","link","found","fullName","nn","linkedTypes","importType","linkedType","actualType","prefix","toLowerCase","makePropsTable","narrow","preprocessDesc","constr","isInterface","anyHaveDefault","some","hasDefault","linkOptions","links","ps","prop","toTypeScriptFunction","de","esc","h","JSON","stringify","Type","noExpand","spread","noToc","properties","isRecord","extends","desc","ext","pr","fnProps","functions","isStatic","all","static","ns","details","displayInDetails","typeWithLink","useCode","import","wrapCode","codedName","LINE","twl","useTag","e","foundExt","le","td","extendS","table","Method","_methodReturn","methodAsync","methodReturn","clearNamespace","Import","from","homedir","os","removeNamespace","addConstructorProperty","isMethod","search","prebody","body","parseTypes","restProps","als","type2","module","exports","xml","parseFile","root","Root","ns1","imports","types","extracted","im"]
}
